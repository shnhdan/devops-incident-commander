#!/usr/bin/env python3
"""
Resilient Gemini-powered Incident Commander
- Multi-model fallback
- Slack Block Kit alerts
- Quota-safe
"""

import google.generativeai as genai
import json
import os
import requests
from dotenv import load_dotenv
from elasticsearch import Elasticsearch

# --------------------------------------------------
# Setup
# --------------------------------------------------
load_dotenv()

genai.configure(api_key=os.getenv("GEMINI_API_KEY"))

MODEL_PRIORITY = [
    "gemini-1.5-flash-latest",
    "gemini-1.5-pro-latest",
]


def generate_with_fallback(prompt):
    """
    Try models in priority order.
    If quota exceeded or failure â†’ fallback.
    """
    for model_name in MODEL_PRIORITY:
        try:
            model = genai.GenerativeModel(model_name)

            response = model.generate_content(
                prompt,
                generation_config={
                    "temperature": 0.3,
                    "max_output_tokens": 512,
                },
            )

            return response.text, model_name

        except Exception as e:
            print(f"âš ï¸ Model {model_name} failed: {e}")
            continue

    # Final fallback (no Gemini available)
    return (
        "âš ï¸ All Gemini models unavailable. Returning raw results.",
        None,
    )


# --------------------------------------------------
# Elasticsearch client
# --------------------------------------------------
es = Elasticsearch(
    os.getenv("ELASTIC_ENDPOINT"),
    basic_auth=(
        os.getenv("ELASTIC_USERNAME"),
        os.getenv("ELASTIC_PASSWORD"),
    ),
    verify_certs=True,
)


# --------------------------------------------------
# Slack Notification (Enterprise Format)
# --------------------------------------------------
def send_slack_notification(message):
    webhook = os.getenv("SLACK_WEBHOOK_URL")
    if not webhook:
        return

    severity = "INFO"
    color = "#2563eb"

    if "CRITICAL" in message.upper():
        severity = "CRITICAL"
        color = "#dc2626"
    elif "WARNING" in message.upper():
        severity = "WARNING"
        color = "#f59e0b"
    elif "ERROR" in message.upper():
        severity = "ERROR"
        color = "#ef4444"

    payload = {
        "attachments": [
            {
                "color": color,
                "blocks": [
                    {
                        "type": "header",
                        "text": {
                            "type": "plain_text",
                            "text": f"ðŸš¨ Incident Report - {severity}",
                        },
                    },
                    {
                        "type": "section",
                        "text": {
                            "type": "mrkdwn",
                            "text": message,
                        },
                    },
                    {
                        "type": "context",
                        "elements": [
                            {
                                "type": "mrkdwn",
                                "text": "Generated by Incident Commander (Gemini + Elasticsearch)",
                            }
                        ],
                    },
                ],
            }
        ]
    }

    try:
        requests.post(webhook, json=payload)
    except Exception as e:
        print(f"Slack error: {e}")


# --------------------------------------------------
# Incident Commander
# --------------------------------------------------
class IncidentCommander:

    def __init__(self):
        self.tools = {
            "detect_errors": self.detect_error_spikes,
            "detect_metrics": self.detect_metric_anomalies,
            "analyze_incident": self.analyze_with_enrichment,
            "search_runbook": self.search_runbooks,
        }

    # ----------------------------
    # TOOL 1
    # ----------------------------
    def detect_error_spikes(self, time_window="1 hour", threshold=10):

        query = """
        FROM app-logs
        | WHERE severity IN ("ERROR", "CRITICAL")
        | STATS error_count = COUNT(*) BY service_name, error_code
        | WHERE error_count > 5
        | SORT error_count DESC
        """

        try:
            result = es.esql.query(query=query)
            return {"success": True, "data": result["values"]}
        except Exception as e:
            return {"success": False, "error": str(e)}

    # ----------------------------
    # TOOL 2
    # ----------------------------
    def detect_metric_anomalies(self):

        query = """
        FROM system-metrics
        | STATS max_value = MAX(value) BY service_name, metric_name
        | WHERE max_value > 80
        """

        try:
            result = es.esql.query(query=query)
            return {"success": True, "data": result["values"]}
        except Exception as e:
            return {"success": False, "error": str(e)}

    # ----------------------------
    # TOOL 3
    # ----------------------------
    def analyze_with_enrichment(self):

        query = """
        FROM app-logs
        | WHERE severity == "CRITICAL"
        | STATS error_count = COUNT(*) BY service_name
        | WHERE error_count > 5
        """

        try:
            result = es.esql.query(query=query)
            return {"success": True, "data": result["values"]}
        except Exception as e:
            return {"success": False, "error": str(e)}

    # ----------------------------
    # TOOL 4
    # ----------------------------
    def search_runbooks(self, search_term="error"):

        try:
            result = es.search(
                index="runbooks",
                body={
                    "query": {
                        "multi_match": {
                            "query": search_term,
                            "fields": [
                                "error_pattern^3",
                                "title^2",
                                "solution",
                            ],
                        }
                    },
                    "size": 3,
                },
            )

            return {
                "success": True,
                "data": [hit["_source"] for hit in result["hits"]["hits"]],
            }

        except Exception as e:
            return {"success": False, "error": str(e)}

    # --------------------------------------------------
    # Orchestration
    # --------------------------------------------------
    def decide_and_execute(self, user_query):

        decision_prompt = f"""
User query: "{user_query}"

Decide which tool to use:
- detect_errors
- detect_metrics
- analyze_incident
- search_runbook

Respond in JSON:
{{ "tools_to_use": ["tool"] }}
"""

        decision_text, model_used = generate_with_fallback(decision_prompt)

        try:
            decision = json.loads(decision_text)
        except Exception:
            decision = {"tools_to_use": ["detect_errors"]}

        results = {}

        for tool in decision.get("tools_to_use", []):
            if tool in self.tools:
                results[tool] = self.tools[tool]()

        format_prompt = f"""
User Query: {user_query}

Results:
{json.dumps(results, indent=2)}

Summarize clearly.
Mention severity if CRITICAL.
Keep under 200 words.
"""

        summary, model_used = generate_with_fallback(format_prompt)

        # Slack Auto-send
        send_slack_notification(summary)

        return {
            "model_used": model_used,
            "decision": decision,
            "tool_results": results,
            "response": summary,
        }


# --------------------------------------------------
# CLI
# --------------------------------------------------
if __name__ == "__main__":
    commander = IncidentCommander()

    print("ðŸš¨ Incident Commander Ready (Resilient Mode)")
    while True:
        query = input("\nðŸ’¬ You: ")
        if query.lower() in ["quit", "exit"]:
            break

        result = commander.decide_and_execute(query)

        print("\nðŸ“Š Incident Report:")
        print(result["response"])
        print(f"\n(Model used: {result['model_used']})")
